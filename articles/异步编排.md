---
title: 异步编排
date: 2025-09-16
categories: 技术
tags: 
cover: 
---


# 异步编排
异步：多线程

编排：执行顺序

CompletableFuture是jdk8的新特性,主要是用于异步调用，内部封装了线程池,也支持自定义线程池，可以将请求或者处理过程，进行异步处理。

异步执行一个任务时，我们一般是使用自定义的线程池Executor去创建执行的。如果不需要有返回值， 任务实现Runnable接口；如果需要有返回值，任务实现Callable接口，调用Executor的submit方法，再使用Future获取即可。如果多个线程存在前后依赖的话，我们怎么处理呢？其实可用CompeletableFuture。

CompeletableFuture对前后有依赖顸的异步任务的调用有点类似于前面我们学过的axios的回调函数，所以也称之为异步编排技术。

```java
1.CompletableFuture:
  completedFuture():类似于Callable接口的多线程
  
  runAsync(Runnable,ExecutorService):适用于无参无返回值,可以使用自定义的线程池
  runAsync(Runnable):适用于无参无返回值,使用默认的线程池(ForkJoinPool)
  
  supply(Supplier,ExecutorService)：适用于无参有返回值,可以使用自定义的线程池
  supply(Supplier)：适用于无参有返回值,使用默认的线程池(ForkJoinPool)
  
  
  thenRunAync(Runnable,ExecutorService):表示使用新的线程[自定义线程池中]继续完成某个任务,无参无返回值
  thenRunAync(Runnable): 表示使用新的线程[默认的线程池中]继续完成某个任务,无参无返回值
  thenRun(Runnable): 表示使用上一个线程继续完成某个任务,无参无返回值
  
  
  thenAcceptAync(Consumer,ExecutorService):表示使用新的线程[自定义线程池中]继续完成某个任务,有参无返回值
  thenAcceptAync(Consumer): 表示使用新的线程[默认的线程池中]继续完成某个任务,有参无返回值
  thenAccept(Consumer): 表示使用上一个线程继续完成某个任务,有参无返回值
  
  
  thenApplyAync(Function,ExecutorService):表示使用新的线程[自定义线程池中]继续完成某个任务,有参有返回值
  thenApplytAync(Function): 表示使用新的线程[默认的线程池中]继续完成某个任务,有参有返回值
  thenApply(Function): 表示使用上一个线程继续完成某个任务,有参有返回值
  
  
  
  whenCompleteAsync(BiConsumer,threadPoolExecutor):表示使用一个新的线程[自定线程池],任务可以接收到上一个线程的返回结果和异常信息,无返回值
  whenCompleteAsync(BiConsumer):表示使用一个新的线程[默认线程池],任务可以接收到上一个线程的返回结果和异常信息,无返回值
  whenComplete(BiConsumer):
  
  
  exceptionally(Function):表示使用默认线程池中的新的线程处理这个异常信息，还能提供一个默认的返回值。
  
  handleAsync(Function,threadPoolExecutor)::表示使用一个新的线程[自定线程池],任务可以接收到上一个线程的返回结果和异常信息,有返回值
  handleAsync(Function)::表示使用一个新的线程[默认线程池],任务可以接收到上一个线程的返回结果和异常信息,有返回值
  handle(Function)::表示使用一个新的线程[默认线程池],任务可以接收到上一个线程的返回结果和异常信息,有返回值
  
  
  ---------当两个线程都执行完成之后，再去线程池中拿一个新的线程去执行这个任务。
  
  runAfterBothAsync(CompletionStage,Runnable,threadPoolExecutor):使用自定义线程池新的线程，无参无返回值
  runAfterBothAsync(CompletionStage,Runnable)::使用默认线程池新的线程，无参无返回值
  runAfterBoth(CompletionStage,Runnable,threadPoolExecutor):使用原来的线程，无参无返回值
  
  
  thenAcceptBothAsync(CompletionStage,BiConsumer,threadPoolExecutor):有参无返回值
  thenAcceptBothAsync(CompletionStage,BiConsumer):有参无返回值
  thenAcceptBoth(CompletionStage,BiConsumer,threadPoolExecutor):有参无返回值
  
  
  thenCombineAsync(CompletionStage,BiFunction,threadPoolExecutor):有参有返回值
  thenCombineAsync(CompletionStage,BiFunction):有参有返回值
  thenCombine(CompletionStage,BiFunction):有参有返回值
  
  CompletableFuture.allOf(CompletionStage ...):表示任意多个线程都执行完成之后，再执行啥？
  
  -------------------------当两个线程任何一个执行完成之后，再去线程池中拿一个新的线程去执行这个任务。-----------
  
  A线程.runAfterEitherAsync(CompletionStage[B线程],Runnable,threadPoolExecutor):
  A线程.runAfterEitherAsync(CompletionStage[B线程],Runnable):
  A线程.runAfterEither(CompletionStage[B线程],Runnable,threadPoolExecutor):
  
  
  A线程.acceptAfterEitherAsync(CompletionStage[B线程],Runnable,threadPoolExecutor):
  A线程.acceptAfterEitherAsync(CompletionStage[B线程],Runnable):
  A线程.acceptfterEither(CompletionStage[B线程],Runnable,threadPoolExecutor):
  
  
  
   A线程.applyToEitherAsync(CompletionStage[B线程],Runnable,threadPoolExecutor):
   A线程.applyToEitherAsync(CompletionStage[B线程],Runnable):
   A线程.applyToEitherAsync(CompletionStage[B线程],Runnable,threadPoolExecutor):
  
 
   CompletableFuture.anyOf(CompletableFuture ...):任意一个线程完成之后，都可以继续...
   
```